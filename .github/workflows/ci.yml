name: CI
on:
  push:
    branches:
      - main
  pull_request:
    branches:
      - main
  workflow_dispatch:
    inputs:
      runner_label:
        description: 'Runner label to use'
        required: false
        type: choice
        options:
          - 'self-hosted'
          - 'magalu'
          - 'local-macos'
          - 'github-hosted'
        default: 'github-hosted'
      disable_scan:
        description: Disable Gradle build scan
        required: false
        type: boolean
        default: false
      test_log_level:
        description: 'Gradle log level for test tasks'
        required: false
        type: choice
        options:
          - 'default'
          - 'info'
          - 'debug'
        default: 'default'
  # Event-driven trigger: when runner-provision.yml completes, this workflow
  # auto-resumes without wasting compute cycles on polling during approval wait
  workflow_run:
    workflows: ['Infra: Provision Magalu Runner']
    types: [completed]
    branches: [main]
env:
  # Preferred OS for single-run checks (Verify JAR, Sonar, artifacts).
  # Override via repo variable CI_PRIMARY_OS (e.g., macos-15).
  # Default: ubuntu-24.04 (faster, cheaper than macOS)
  PRIMARY_OS: >-
    ${{ (github.event.inputs.runner_label == 'local-macos' || vars.CI_RUNNER_LABEL == 'local-macos') && 'local-macos' ||
        (github.event.inputs.runner_label == 'magalu' || vars.CI_RUNNER_LABEL == 'magalu') && 'magalu' ||
        (vars.CI_PRIMARY_OS || 'ubuntu-24.04') }}
concurrency:
  # PRs: group by head_ref (cancel outdated runs for same branch)
  # Main pushes: group by SHA (allows parallel runs per commit for fast regression detection)
  # workflow_run: group by triggering run ID (allows resume after provisioning)
  # workflow_dispatch: group by run ID (never wait for other CI runs)
  group: >-
    ${{ github.workflow }}-${{
      github.event_name == 'pull_request' && github.head_ref ||
      github.event_name == 'workflow_run' && github.event.workflow_run.id ||
      github.event_name == 'workflow_dispatch' && github.run_id ||
      github.sha
    }}
  cancel-in-progress: ${{ github.event_name == 'pull_request' }}

# ============================================================================
# RUNNER CONFIGURATION
# ============================================================================
# Priority: workflow_dispatch input > CI_RUNNER_LABEL repo variable > self-hosted
#
# Default: github-hosted runner (standard GitHub Actions runners)
#
# Runner options:
#   - self-hosted: Local runner (fastest, no cost)
#   - magalu: Magalu Cloud ephemeral runner (use runner-provision.yml first!)
#   - github-hosted: GitHub-hosted runners (default, macos-15 for PRs, matrix for main)
#
# To switch runners permanently:
#   Settings ‚Üí Secrets and variables ‚Üí Actions ‚Üí Variables ‚Üí New repository variable
#   Name: CI_RUNNER_LABEL  Value: github-hosted (or magalu)
#
# To switch for a single run:
#   Actions ‚Üí CI ‚Üí Run workflow ‚Üí runner_label: <choice>
#
# Magalu Cloud runners:
#   1. Run "Infra: Provision Magalu Runner" workflow first
#   2. Then run CI with runner_label: magalu
#   3. Run "Infra: Destroy Magalu Runner" when done (or wait for nightly cleanup)
#
# NOTE: Avoiding ubuntu-latest due to stability issues causing builds to hang.
# See: https://github.com/actions/runner-images/issues/13182
#
# Available runner labels: https://github.com/actions/runner-images#available-images
# ============================================================================

jobs:
  check-paths:
    runs-on: ${{ vars.CI_FAST_RUNNER || 'ubuntu-latest' }}
    timeout-minutes: 5
    permissions:
      contents: read
    outputs:
      run_main_ci: ${{ steps.filter.outputs.run_main_ci }}
    steps:
      - uses: actions/checkout@8e8c483db84b4bee98b60c0593521ed34d9990e8 # v6
        with:
          fetch-depth: ${{ github.event_name == 'pull_request' && 1 || 0 }}
          persist-credentials: false
      - uses: dorny/paths-filter@de90cc6fb38fc0963ad72b210f1f284cd68cea36 # v3.0.2
        id: filter
        with:
          # For workflow_run events, use the triggering workflow's head commit as base
          # This fixes the 'before field is missing' warning
          base: ${{ github.event_name == 'workflow_run' && github.event.workflow_run.head_sha || '' }}
          # NOTE: Only positive patterns work reliably with paths-filter
          # Exclusions like !**/*.md don't work as expected with default 'some' predicate
          # Files in excluded dirs (docs/, .agent/) simply won't match positive patterns
          filters: |
            run_main_ci:
              # Code that requires CI to run
              - 'src/**'
              - 'gradle/**'
              # Single-level modules (e.g., groovy-lsp/src/)
              - 'groovy-*/src/**'
              - 'groovy-*/*.gradle.kts'
              # groovyparser-core module (doesn't follow groovy-* naming)
              - 'groovyparser-core/src/**'
              - 'groovyparser-core/*.gradle.kts'
              # Nested modules (e.g., groovy-diagnostics/codenarc/src/)
              - 'groovy-diagnostics/*/src/**'
              - 'groovy-diagnostics/*/*.gradle.kts'
              - 'jupyter/*/src/**'
              - 'jupyter/*/*.gradle.kts'
              - 'tools/*/src/**'
              - 'tools/*/*.gradle.kts'
              - 'viz/*/src/**'
              - 'viz/*/*.gradle.kts'
              # Multi-project parser modules
              - 'parser/**'
              # Root-level files
              - 'tests/**'
              - '*.gradle'
              - '*.gradle.kts'
              - 'gradle.properties'
              - 'settings.gradle.kts'
              - '.github/workflows/ci.yml'

  check-runner:
    name: Check Runner Availability
    runs-on: ubuntu-latest
    timeout-minutes: 10
    permissions:
      contents: read
    needs: check-paths
    # Skip for workflow_run - runner is already available from completed provisioning
    if: |
      github.event_name != 'workflow_run' &&
      (needs.check-paths.outputs.run_main_ci == 'true' || github.event_name == 'workflow_dispatch')
    outputs:
      provisioning_triggered: ${{ steps.exit-early.outputs.provisioning_triggered }}
    steps:
      - name: Checkout (for local action)
        uses: actions/checkout@8e8c483db84b4bee98b60c0593521ed34d9990e8 # v6
        with:
          sparse-checkout: .github/actions
          persist-credentials: false

      - name: Determine Runner Label
        id: mode
        run: |
          # Priority: Input > Variable > Default(github-hosted)
          LABEL="${{ github.event.inputs.runner_label || vars.CI_RUNNER_LABEL || 'github-hosted' }}"
          echo "label=$LABEL" >> "$GITHUB_OUTPUT"
          echo "Checking availability for: $LABEL"

      # --- Magalu Check ---
      - name: Check Magalu runner
        if: steps.mode.outputs.label == 'magalu'
        id: check-magalu
        uses: ./.github/actions/runner-status
        with:
          mode: check
          label: magalu
          github-token: ${{ secrets.GH_PAT_RUNNER }}

      - name: Trigger provisioning (Magalu)
        if: steps.mode.outputs.label == 'magalu' && steps.check-magalu.outputs.has-runners != 'true'
        id: exit-early
        env:
          GH_TOKEN: ${{ secrets.GH_PAT_RUNNER }}
        run: |
          echo "Triggering runner-provision.yml..."
          gh workflow run runner-provision.yml --repo "${{ github.repository }}"
          echo ""
          echo "‚è≥ Provisioning triggered. Manual approval may be required."
          echo "üëâ Go to: https://github.com/${{ github.repository }}/actions/workflows/runner-provision.yml"
          echo ""
          echo "‚ÑπÔ∏è This CI run will exit now to avoid wasting compute cycles."
          echo "::notice::CI exiting early. Will auto-resume via workflow_run after runner-provision.yml completes."
          # Set output to signal downstream jobs to skip
          echo "provisioning_triggered=true" >> "$GITHUB_OUTPUT"

      # --- Local macOS Check ---
      - name: Check Local macOS runner
        if: steps.mode.outputs.label == 'local-macos'
        id: check-local
        uses: ./.github/actions/runner-status
        with:
          mode: check
          label: local-macos
          github-token: ${{ secrets.GH_PAT_RUNNER }}

      - name: Verify Local macOS Availability
        if: steps.mode.outputs.label == 'local-macos' && steps.check-local.outputs.has-runners != 'true'
        run: |
          echo "‚ùå No local macOS runner found online with label 'local-macos'."
          echo ""
          echo "To set up a runner on your Mac:"
          echo "  ./tools/github/actions/setup-macos-runner.sh"
          echo ""
          echo "Ensure the runner service is active:"
          echo "  cd ~/.gha-runners/groovy-lsp-*"
          echo "  ./svc.sh status"
          echo ""
          exit 1

      # --- Summary ---
      - name: Runner Check Summary
        if: always()
        run: |
          LABEL="${{ steps.mode.outputs.label }}"
          echo "Runner label: $LABEL"

          case "$LABEL" in
            "magalu")
              if [[ "${{ steps.check-magalu.outputs.has-runners }}" == "true" ]]; then
                echo "‚úÖ Magalu runner available"
              else
                echo "‚è≥ Magalu runner provisioning triggered"
              fi
              ;;
            "local-macos")
              if [[ "${{ steps.check-local.outputs.has-runners }}" == "true" ]]; then
                echo "‚úÖ Local macOS runner available"
              else
                echo "‚ùå Local macOS runner check failed (see above)"
              fi
              ;;
            "github-hosted")
              echo "‚úÖ Using GitHub-hosted cloud runners (no check needed)"
              ;;
            *)
              echo "‚úÖ Runner check complete for: $LABEL"
              ;;
          esac

  lint:
    name: Lint
    needs: [check-paths, check-runner]
    # Run if paths require CI and no provisioning triggered
    if: |
      always() && (
        (github.event_name == 'workflow_run' && github.event.workflow_run.conclusion == 'success') ||
        (needs.check-runner.result == 'success' && needs.check-runner.outputs.provisioning_triggered != 'true')
      )
    runs-on: ${{ vars.CI_FAST_RUNNER || 'ubuntu-latest' }}
    timeout-minutes: 10
    permissions:
      contents: read
    steps:
      - name: Checkout code
        uses: actions/checkout@8e8c483db84b4bee98b60c0593521ed34d9990e8 # v6
        with:
          fetch-depth: 1
          persist-credentials: false

      - name: Set up JDK 17
        uses: actions/setup-java@f2beeb24e141e01a676f977032f5a29d81c9e27e # v5.1.0
        with:
          distribution: temurin
          java-version: 17

      - name: Setup Gradle
        uses: gradle/actions/setup-gradle@4d9f0ba0025fe599b4ebab900eb7f3a1d93ef4c2 # v5.0.0
        with:
          cache-read-only: ${{ github.ref != 'refs/heads/main' && github.event_name == 'pull_request' && github.event.pull_request.head.repo.full_name != github.repository }}

      - name: Run Lint
        run: ./gradlew lint --parallel --build-cache --stacktrace

  build:
    name: Build and Test
    needs: [check-paths, check-runner]
    # Run if:
    # 1. workflow_run from successful provisioning (check-runner was skipped), OR
    # 2. Normal trigger (push/PR/dispatch) with relevant paths AND no provisioning triggered
    if: |
      always() && (
        (github.event_name == 'workflow_run' && github.event.workflow_run.conclusion == 'success') ||
        (needs.check-runner.result == 'success' && needs.check-runner.outputs.provisioning_triggered != 'true')
      )
    timeout-minutes: 45
    # For self-hosted runners, we need label arrays; for cloud runners, use the matrix value directly
    runs-on: ${{ matrix.os == 'magalu' && fromJSON('["self-hosted", "magalu", "groovy-lsp"]') || matrix.os == 'local-macos' && fromJSON('["self-hosted", "local-macos", "groovy-lsp"]') || matrix.os }}
    permissions:
      checks: write
      contents: read
    strategy:
      fail-fast: false
      matrix:
        # Runner selection:
        #   - magalu: Magalu Cloud ephemeral runner (provision first via runner-provision.yml)
        #   - local-macos: Local macOS runner (setup with tools/github/actions/setup-macos-runner.sh)
        #   - github-hosted: GitHub-hosted (Ubuntu is now the default for PRs and main, macOS remains as an additional check)
        # NOTE: macOS is retained for compatibility, but Ubuntu is the more stable default
        # See: https://github.com/actions/runner-images/issues/13182
        os: ${{ fromJSON( (github.event.inputs.runner_label == 'local-macos' || vars.CI_RUNNER_LABEL == 'local-macos') && '["local-macos"]' || (github.event.inputs.runner_label == 'magalu' || vars.CI_RUNNER_LABEL == 'magalu') && '["magalu"]' || (github.event_name == 'pull_request' && format('["{0}"]', vars.CI_PRIMARY_OS || 'ubuntu-24.04') || format('["{0}", "{1}"]', vars.CI_PRIMARY_OS || 'ubuntu-24.04', (vars.CI_PRIMARY_OS == 'macos-15') && 'ubuntu-24.04' || 'macos-15')) ) }}
        java: ${{ fromJSON( (github.event.inputs.runner_label == 'local-macos' || vars.CI_RUNNER_LABEL == 'local-macos' || github.event.inputs.runner_label == 'magalu' || vars.CI_RUNNER_LABEL == 'magalu') && '[17]' || (github.event_name == 'pull_request' && '[17]' || '[17, 21]') ) }}
        exclude:
          - os: ubuntu-24.04
            java: 21
    steps:
      - name: Checkout code
        uses: actions/checkout@8e8c483db84b4bee98b60c0593521ed34d9990e8 # v6
        with:
          # Shallow clone for PRs (faster), deep clone for main (SonarCloud needs history)
          fetch-depth: ${{ github.event_name == 'pull_request' && 1 || 0 }}
          persist-credentials: false

      - name: üñ•Ô∏è Runner Specs
        shell: bash
        run: |
          # Cross-platform CPU/RAM detection
          # TODO: Add Windows support using: wmic cpu get NumberOfCores, systeminfo for RAM
          if [[ "${{ runner.os }}" == "macOS" ]]; then
            CORES=$(sysctl -n hw.ncpu)
            RAM=$(echo "scale=1; $(sysctl -n hw.memsize) / 1024 / 1024 / 1024" | bc)
            RAM="${RAM} GB"
          elif [[ "${{ runner.os }}" == "Windows" ]]; then
            CORES="N/A (Windows not yet supported)"
            RAM="N/A"
          else
            CORES=$(nproc)
            RAM=$(free -h | awk '/Mem:/ {print $2}')
          fi
          DISK=$(df -h / | awk 'NR==2 {print $4 " free"}' 2>/dev/null || echo "N/A")
          HOSTNAME=$(hostname)

          # Print to console (visible immediately)
          echo "‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó"
          echo "‚ïë        Runner Specifications           ‚ïë"
          echo "‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£"
          echo "‚ïë OS:         ${{ runner.os }} / ${{ runner.arch }}"
          echo "‚ïë CPU Cores:  $CORES"
          echo "‚ïë RAM:        $RAM"
          echo "‚ïë Disk:       $DISK"
          echo "‚ïë Hostname:   $HOSTNAME"
          echo "‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù"
          echo ""

          # Also write to summary (for post-job formatted view)
          {
            echo "## üñ•Ô∏è Runner: ${{ runner.name }}"
            echo ""
            echo "| Spec | Value |"
            echo "|------|-------|"
            echo "| **OS** | ${{ runner.os }} / ${{ runner.arch }} |"
            echo "| **CPU Cores** | $CORES |"
            echo "| **RAM** | $RAM |"
            echo "| **Disk** | $DISK |"
            echo "| **Hostname** | $HOSTNAME |"
          } >> "$GITHUB_STEP_SUMMARY"
      - name: Set up JDK ${{ matrix.java }}
        uses: actions/setup-java@f2beeb24e141e01a676f977032f5a29d81c9e27e # v5.1.0
        with:
          distribution: temurin
          java-version: ${{ matrix.java }}
      - name: Setup Gradle
        uses: gradle/actions/setup-gradle@4d9f0ba0025fe599b4ebab900eb7f3a1d93ef4c2 # v5.0.0
        with:
          # Allow writing to cache for main OR PRs from the same repository
          # Read-only for forks to prevent cache poisoning
          cache-read-only: ${{ github.ref != 'refs/heads/main' && github.event_name == 'pull_request' && github.event.pull_request.head.repo.full_name != github.repository }}
          # Self-hosted runners may have pre-existing Gradle User Home - allow overwrite
          cache-overwrite-existing: ${{ matrix.os == 'self-hosted' }}
      - name: Set Gradle flags
        shell: bash
        run: |-
          # Set scan flag
          if [[ "${{ github.event.inputs.disable_scan }}" == "true" ]]; then
            echo "GRADLE_SCAN_FLAG=-Dorg.gradle.scan=false" >> "$GITHUB_ENV"
          else
            echo "GRADLE_SCAN_FLAG=" >> "$GITHUB_ENV"
          fi

          # Set test log level flag
          case "${{ github.event.inputs.test_log_level }}" in
            "info")
              echo "TEST_LOG_FLAG=--info" >> "$GITHUB_ENV"
              ;;
            "debug")
              echo "TEST_LOG_FLAG=--debug" >> "$GITHUB_ENV"
              ;;
            *)
              echo "TEST_LOG_FLAG=" >> "$GITHUB_ENV"
              ;;
          esac

      # NOTE: --parallel and --build-cache are redundant with gradle.properties settings
      # (org.gradle.parallel=true, org.gradle.caching=true) but kept explicit for:
      # 1. Self-documentation - CI intent is clear without checking gradle.properties
      # 2. Defense in depth - CI works even if gradle.properties changes

      # Phase 1: Compile (lint runs in separate parallel job)
      - name: Compile
        run: |
          args=(classes testClasses --parallel --build-cache --stacktrace)
          if [[ -n "${GRADLE_SCAN_FLAG}" ]]; then
            args+=("${GRADLE_SCAN_FLAG}")
          fi
          ./gradlew "${args[@]}"

      # Phase 2: Unit Tests (generates coverage data in .ic files)
      - name: Run Unit Tests
        timeout-minutes: 20
        run: |
          args=(test --parallel --build-cache --stacktrace)
          if [[ -n "${TEST_LOG_FLAG}" ]]; then
            args+=("${TEST_LOG_FLAG}")
          fi
          if [[ -n "${GRADLE_SCAN_FLAG}" ]]; then
            args+=("${GRADLE_SCAN_FLAG}")
          fi
          ./gradlew "${args[@]}"

      # Upload coverage data for parallel coverage job
      - name: Upload Coverage Data
        uses: actions/upload-artifact@b7c566a772e6b6bfb58ed0dc250532a479d7789f # v6.0.0
        with:
          name: coverage-data-${{ matrix.os }}-java${{ matrix.java }}
          path: '**/build/kover/*.ic'
          retention-days: 1

      # Build shadowJar for verification (E2E tests run in parallel job)
      - name: Build Shadow JAR
        if: matrix.os == env.PRIMARY_OS && matrix.java == 17
        run: ./gradlew :groovy-lsp:shadowJar --parallel --build-cache --stacktrace

      # Upload test results BEFORE test reporter to ensure artifacts are preserved
      # even if tests fail (test reporter may fail when tests fail with fail-on-error)
      - name: Upload Test Results
        if: always()
        uses: actions/upload-artifact@b7c566a772e6b6bfb58ed0dc250532a479d7789f # v6.0.0
        with:
          name: test-results-${{ matrix.os }}-java${{ matrix.java }}
          path: |-
            **/build/test-results/
            **/build/reports/tests/
            **/build/reports/problems/
            **/build/reports/kover/
          retention-days: 7

      # NEW: Upload JVM diagnostic logs for deadlock/hang analysis
      # These files are generated by the test monitoring infrastructure in build.gradle.kts
      # - test-jvm.log: JVM events, thread dumps, lock info
      # - test-recording.jfr: Java Flight Recorder data (if Tier 2 enabled)
      # Use fastThread.io or JDK Mission Control to analyze these files
      - name: Upload Test Diagnostic Logs
        if: always()  # Upload even if tests fail or timeout
        uses: actions/upload-artifact@b7c566a772e6b6bfb58ed0dc250532a479d7789f # v6.0.0
        with:
          name: test-diagnostics-${{ matrix.os }}-java${{ matrix.java }}
          path: |-
            **/build/test-jvm.log
            **/build/test-recording.jfr
          retention-days: 7
          if-no-files-found: ignore  # Don't fail if files don't exist (e.g., tests passed quickly)

      - name: Generate Test Report
        uses: dorny/test-reporter@e17be7e0078fc00f61965f3b4032f1e1fdc7fcfb # v2.4.0
        if: success() || failure()
        with:
          name: Test Results (${{ matrix.os }} - Java ${{ matrix.java }})
          path: '**/build/test-results/test/*.xml'
          reporter: java-junit
          # Don't fail the job if there are test failures - let the test step handle that
          # This ensures test results are always uploaded and visible
          fail-on-error: false

      # Verify JAR (built in previous step)
      - name: Resolve shadow JAR
        if: matrix.os == env.PRIMARY_OS && matrix.java == 17
        id: resolve-jar
        shell: bash
        run: |-
          set -euo pipefail
          shopt -s nullglob
          jar_files=(groovy-lsp/build/libs/gls-*-all.jar)
          if [[ ${#jar_files[@]} -eq 0 ]]; then
            echo "::error::Shadow JAR not found in groovy-lsp/build/libs"
            exit 1
          fi
          echo "jar_path=${jar_files[0]}" >> "$GITHUB_OUTPUT"

      - name: Verify JAR
        if: matrix.os == env.PRIMARY_OS && matrix.java == 17
        run: |-
          echo "Testing JAR with --help flag..."
          java -jar "${{ steps.resolve-jar.outputs.jar_path }}" --help

      - name: Upload JAR artifact
        if: matrix.os == env.PRIMARY_OS && matrix.java == 17
        uses: actions/upload-artifact@b7c566a772e6b6bfb58ed0dc250532a479d7789f # v6.0.0
        with:
          name: groovy-lsp-jar-${{ matrix.os }}-java${{ matrix.java }}
          path: ${{ steps.resolve-jar.outputs.jar_path }}
          retention-days: 7

  # Coverage reports run in parallel with E2E tests (both need build to complete)
  coverage:
    name: Coverage Report
    needs: build
    if: |
      always() &&
      needs.build.result == 'success'
    # Use same runner selection logic as PRIMARY_OS to respect workflow_dispatch
    runs-on: ${{ (github.event.inputs.runner_label == 'local-macos' || vars.CI_RUNNER_LABEL == 'local-macos') && fromJSON('["self-hosted", "local-macos", "groovy-lsp"]') || (github.event.inputs.runner_label == 'magalu' || vars.CI_RUNNER_LABEL == 'magalu') && fromJSON('["self-hosted", "magalu", "groovy-lsp"]') || (vars.CI_PRIMARY_OS || 'ubuntu-24.04') }}
    timeout-minutes: 10
    permissions:
      contents: read
    steps:
      - name: Checkout code
        uses: actions/checkout@8e8c483db84b4bee98b60c0593521ed34d9990e8 # v6
        with:
          fetch-depth: ${{ github.event_name == 'pull_request' && 1 || 0 }}
          persist-credentials: false

      - name: Set up JDK 17
        uses: actions/setup-java@f2beeb24e141e01a676f977032f5a29d81c9e27e # v5.1.0
        with:
          distribution: temurin
          java-version: 17

      - name: Setup Gradle
        uses: gradle/actions/setup-gradle@4d9f0ba0025fe599b4ebab900eb7f3a1d93ef4c2 # v5.0.0
        with:
          cache-read-only: ${{ github.ref != 'refs/heads/main' && github.event_name == 'pull_request' && github.event.pull_request.head.repo.full_name != github.repository }}

      - name: Download Coverage Data
        uses: actions/download-artifact@37930b1c2abaa49bbe596cd826c3c89aef350131 # v7.0.0
        with:
          pattern: coverage-data-*
          merge-multiple: true
          path: .

      - name: Set Gradle flags
        shell: bash
        run: |
          if [[ "${{ github.event.inputs.disable_scan }}" == "true" ]]; then
            echo "GRADLE_SCAN_FLAG=-Dorg.gradle.scan=false" >> "$GITHUB_ENV"
          else
            echo "GRADLE_SCAN_FLAG=" >> "$GITHUB_ENV"
          fi

      # Generate coverage reports (reads .ic files from downloaded artifacts)
      # NOTE: Split from test task to avoid Kover hang bug when running in same invocation
      # with --parallel. See: https://github.com/Kotlin/kotlinx-kover/issues/509
      - name: Generate Coverage Reports
        run: |
          args=(koverXmlReport koverHtmlReport --parallel --build-cache --stacktrace)
          if [[ -n "${GRADLE_SCAN_FLAG}" ]]; then
            args+=("${GRADLE_SCAN_FLAG}")
          fi
          ./gradlew "${args[@]}"

      # SonarCloud (needs coverage reports)
      - name: SonarCloud Analysis
        if: ((github.event_name == 'push' && github.ref == 'refs/heads/main') || (github.event_name == 'pull_request' && github.event.pull_request.base.ref == 'main' && github.event.pull_request.head.repo.full_name == github.repository))
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}
        run: |
          args=(sonar --info)
          if [[ -n "${GRADLE_SCAN_FLAG}" ]]; then
            args+=("${GRADLE_SCAN_FLAG}")
          fi
          ./gradlew "${args[@]}"

      - name: Upload Coverage Reports
        uses: actions/upload-artifact@b7c566a772e6b6bfb58ed0dc250532a479d7789f # v6.0.0
        with:
          name: coverage-reports
          path: '**/build/reports/kover/'
          retention-days: 7

  # E2E tests run in parallel with coverage (both need build to complete)
  e2e-test:
    name: E2E Tests
    needs: build
    if: |
      always() &&
      needs.build.result == 'success'
    # Run on PRIMARY_OS only - E2E tests are platform-independent LSP protocol tests
    # Use same runner selection logic as PRIMARY_OS to respect workflow_dispatch
    runs-on: ${{ (github.event.inputs.runner_label == 'local-macos' || vars.CI_RUNNER_LABEL == 'local-macos') && fromJSON('["self-hosted", "local-macos", "groovy-lsp"]') || (github.event.inputs.runner_label == 'magalu' || vars.CI_RUNNER_LABEL == 'magalu') && fromJSON('["self-hosted", "magalu", "groovy-lsp"]') || (vars.CI_PRIMARY_OS || 'ubuntu-24.04') }}
    timeout-minutes: 20
    permissions:
      contents: read
    steps:
      - name: Checkout code
        uses: actions/checkout@8e8c483db84b4bee98b60c0593521ed34d9990e8 # v6
        with:
          fetch-depth: 1
          persist-credentials: false

      - name: Set up JDK 17
        uses: actions/setup-java@f2beeb24e141e01a676f977032f5a29d81c9e27e # v5.1.0
        with:
          distribution: temurin
          java-version: 17

      - name: Setup Gradle
        uses: gradle/actions/setup-gradle@4d9f0ba0025fe599b4ebab900eb7f3a1d93ef4c2 # v5.0.0
        with:
          cache-read-only: ${{ github.ref != 'refs/heads/main' && github.event_name == 'pull_request' && github.event.pull_request.head.repo.full_name != github.repository }}

      - name: Set Gradle flags
        shell: bash
        run: |
          if [[ "${{ github.event.inputs.disable_scan }}" == "true" ]]; then
            echo "GRADLE_SCAN_FLAG=-Dorg.gradle.scan=false" >> "$GITHUB_ENV"
          else
            echo "GRADLE_SCAN_FLAG=" >> "$GITHUB_ENV"
          fi

          case "${{ github.event.inputs.test_log_level }}" in
            "info")
              echo "TEST_LOG_FLAG=--info" >> "$GITHUB_ENV"
              ;;
            "debug")
              echo "TEST_LOG_FLAG=--debug" >> "$GITHUB_ENV"
              ;;
            *)
              echo "TEST_LOG_FLAG=" >> "$GITHUB_ENV"
              ;;
          esac

      # E2E Tests (automatically builds shadowJar via task dependency)
      # Now runs with intelligent parallel forks (2-3 based on runner OS)
      - name: Run E2E Tests
        timeout-minutes: 15
        run: |
          args=(:tests:e2eTest --parallel --build-cache --stacktrace)
          if [[ -n "${TEST_LOG_FLAG}" ]]; then
            args+=("${TEST_LOG_FLAG}")
          fi
          if [[ -n "${GRADLE_SCAN_FLAG}" ]]; then
            args+=("${GRADLE_SCAN_FLAG}")
          fi
          ./gradlew "${args[@]}"

      - name: Upload E2E Test Results
        if: always()
        uses: actions/upload-artifact@b7c566a772e6b6bfb58ed0dc250532a479d7789f # v6.0.0
        with:
          name: e2e-test-results
          path: '**/build/test-results/e2eTest/'
          retention-days: 7

  # Cross-platform smoke tests - verify JAR works on key platforms
  # Lighter weight than release matrix, runs on every main merge for faster feedback
  smoke-test:
    name: Smoke Test (${{ matrix.os }})
    needs: build
    if: github.ref == 'refs/heads/main' && github.event_name == 'push'
    runs-on: ${{ matrix.os }}
    timeout-minutes: 10
    permissions:
      contents: read
    strategy:
      fail-fast: false
      matrix:
        # Key platforms for quick validation (full matrix in release.yml)
        os: [ubuntu-24.04, macos-15, windows-2022]
    steps:
      - name: Download JAR artifact
        uses: actions/download-artifact@37930b1c2abaa49bbe596cd826c3c89aef350131 # v7.0.0
        with:
          pattern: groovy-lsp-jar-*
          merge-multiple: true
          path: dist

      - name: Set up JDK 17
        uses: actions/setup-java@f2beeb24e141e01a676f977032f5a29d81c9e27e # v5.1.0
        with:
          distribution: temurin
          java-version: 17

      - name: Verify Java version
        run: java -version

      - name: Run smoke test
        shell: bash
        run: |
          JAR_FILE=$(find dist -name "*.jar" -type f | head -1)
          if [[ -z "$JAR_FILE" ]]; then
            echo "::error::No JAR file found in dist/"
            exit 1
          fi
          echo "Testing JAR: $JAR_FILE"
          java -jar "$JAR_FILE" --help
          echo "‚úÖ Smoke test passed on ${{ matrix.os }}!"

  validate:
    name: Validation Check
    runs-on: ${{ vars.CI_FAST_RUNNER || 'ubuntu-latest' }}
    timeout-minutes: 5
    permissions:
      contents: read
    needs: [lint, build, coverage, e2e-test, check-runner, check-paths]
    if: always()
    steps:
      - name: Check build status
        run: |
          LINT_RESULT="${{ needs.lint.result }}"
          BUILD_RESULT="${{ needs.build.result }}"
          COVERAGE_RESULT="${{ needs.coverage.result }}"
          E2E_RESULT="${{ needs.e2e-test.result }}"
          PROVISIONING="${{ needs.check-runner.outputs.provisioning_triggered }}"
          RUN_MAIN_CI="${{ needs.check-paths.outputs.run_main_ci }}"

          echo "Lint result: $LINT_RESULT"
          echo "Build result: $BUILD_RESULT"
          echo "Coverage result: $COVERAGE_RESULT"
          echo "E2E result: $E2E_RESULT"
          echo "Provisioning triggered: $PROVISIONING"
          echo "Run main CI: $RUN_MAIN_CI"

          # If paths filter determined no CI needed, skipped build is OK
          if [[ "$RUN_MAIN_CI" != "true" && "$BUILD_RESULT" == "skipped" ]]; then
            echo "‚ÑπÔ∏è Build skipped - no relevant code changes detected"
            echo "   Only documentation or config files were modified"
            exit 0
          fi

          # If provisioning was triggered, build is expected to be skipped
          if [[ "$PROVISIONING" == "true" && "$BUILD_RESULT" == "skipped" ]]; then
            echo "‚ÑπÔ∏è Build skipped - runner provisioning in progress"
            echo "   CI will resume automatically after provisioning completes"
            exit 0
          fi

          # For workflow_run events, check-runner is skipped so we can't check provisioning_triggered
          if [[ "${{ github.event_name }}" == "workflow_run" ]]; then
            if [[ "$BUILD_RESULT" != "success" ]] || [[ "$LINT_RESULT" != "success" ]] || \
               [[ "$COVERAGE_RESULT" != "success" ]] || [[ "$E2E_RESULT" != "success" ]]; then
              echo "‚ùå One or more jobs failed after provisioning"
              exit 1
            fi
            echo "‚úÖ All checks passed!"
            exit 0
          fi

          # Normal case: all jobs must succeed (or be skipped appropriately)
          FAILED=false
          CANCELLED=false

          check_job_result() {
            local job_name="$1"
            local result="$2"
            if [[ "$result" == "cancelled" ]]; then
              CANCELLED=true
              return
            fi
            if [[ "$result" != "success" ]] && [[ "$result" != "skipped" ]]; then
              echo "‚ùå $job_name failed"
              FAILED=true
            fi
          }

          check_job_result "Lint" "$LINT_RESULT"
          check_job_result "Build" "$BUILD_RESULT"
          check_job_result "Coverage" "$COVERAGE_RESULT"
          check_job_result "E2E" "$E2E_RESULT"

          if [[ "$CANCELLED" == "true" ]]; then
            echo "‚ö†Ô∏è One or more jobs were cancelled"
            echo "   This is expected when a newer commit is pushed to the same PR"
            if [[ "$FAILED" == "true" ]]; then
              echo "   However, other jobs still failed"
              exit 1
            fi
            exit 0
          fi

          if [[ "$FAILED" == "true" ]]; then
            exit 1
          fi

          echo "‚úÖ All checks passed!"
  dependency-check:
    name: Check Dependencies
    runs-on: ${{ vars.CI_FAST_RUNNER || 'ubuntu-latest' }}
    timeout-minutes: 15
    permissions:
      contents: read
    if: github.ref == 'refs/heads/main'
    steps:
      - name: Checkout code
        uses: actions/checkout@8e8c483db84b4bee98b60c0593521ed34d9990e8 # v6
        with:
          persist-credentials: false
      - name: Set up JDK 17
        uses: actions/setup-java@f2beeb24e141e01a676f977032f5a29d81c9e27e # v5.1.0
        with:
          distribution: temurin
          java-version: 17
      - name: Setup Gradle
        uses: gradle/actions/setup-gradle@4d9f0ba0025fe599b4ebab900eb7f3a1d93ef4c2 # v5.0.0
      - name: Check for dependency updates
        run: ./gradlew dependencyUpdates --refresh-dependencies || true
